package depgraph

import "fmt"

// the library graph, as generated by the dagger comment

func (g *Graph) addAllImplicitLibraryDependencyEdges() {
	for _, n := range g.Nodes {
		g.addImplicitEdgesForNode(n)
	}
	edges := []Edge{}
	for _, e := range g.edges {
		edges = append(edges, e)
	}
	g.Edges = edges
}

// procedure is borrowed directly from <https://github.com/mongodb/dagger/blob/master/dagger/repl/query_engine.py#L259>,
// with some modifications, for working in this graph format.

func (g *Graph) addImplicitEdgesForNode(n Node) {
	var edgeType EdgeType

	switch n.Type() {
	case Library:
		edgeType = ImplicitLibraryToLibrary
	case Artifact:
		edgeType = ArtifactToLibrary
	default:
		return
	}

	edge := Edge{
		Type: edgeType,
		FromNode: NodeRelationship{
			GraphID: n.GraphID,
			Name:    n.Name,
		},
		localID: g.nextID,
	}
	g.nextID++

	deps := make(map[string]struct{})
	for _, symEdge := range g.Edges {
		if symEdge.Type != LibraryToSymbol {
			continue
		}

		for _, e := range symEdge.ToNodes {
			symbol := g.nodes[e.Name]

			libs, ok := g.edges[fmt.Sprintf("%d.%d", symbol.GraphID, LibraryToLibrary)]
			if !ok {
				continue
			}

			for _, nodeRel := range libs.ToNodes {
				if nodeRel.Name == n.Name {
					continue
				}

				deps[nodeRel.Name] = struct{}{}
			}
		}
	}

	if len(deps) == 0 {
		return
	}

	for dep := range deps {
		lib := g.nodes[dep]
		edge.ToNodes = append(edge.ToNodes,
			NodeRelationship{
				Name:    lib.Name,
				GraphID: lib.GraphID,
			})
	}

	g.edges[edge.Name()] = edge
}
